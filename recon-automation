#!/usr/bin/env bash

set -euo pipefail

### Global settings ###
domain=""
output_dir=""
pd_tools=("subfinder" "shuffledns" "alterx" "dnsx" "naabu" "httpx" "katana" "urlfinder" "nuclei")


### Functions ###

install_script_tools() {
    printf "\n[INF] Checking if required tools are installed...\n"

    for tool in "${pd_tools[@]}"; do
        if command -v "$tool" &> /dev/null; then
            printf "[INF] $tool is already installed.\n"
            continue
        else
           printf "[WRN] $tool is not installed.\n"
        fi
    done

    printf "[INF] Installing required tools...\n"

    (IFS=,
    pdtm -i "${pd_tools[*]}" -igp)
    
    if [[ $? -eq 0 ]]; then
        printf "\n[INF] All required tools were installed.\n"
    else
        printf "[ERR] Failed to install required tools.\n\n"
        return 1
    fi
}

# Define domain and output directory if unspecified.
define_variables() {
    # Defines the domain if unspecified
    while [[ -z "$domain" ]]; do
        printf "\n[!] Please specify a domain: "
        read -e -r -p "" domain
        [[ -z  "$domain" ]] && printf "[ERR] $domain cannot be empty.\n"
    done
    
    # Defines the output directory if unspecified
    local strip_protocol="${domain#*://}"
    local strip_name="${strip_protocol#www.}"
    local clean_name="${strip_name%%/*}"

    if [[ -n "$output_dir" && -d "$output_dir" ]]; then
       printf "[INF] Using existing directory: $output_dir.\n"
       return 0
    fi

    if [[ -z "$output_dir" ]]; then
        output_dir="$clean_name"
    fi

    if [[ ! -d "$output_dir" ]]; then
        mkdir -p "./$output_dir"
        printf "[INF] Output will be stored in directory: $output_dir.\n"
    else
        printf "[INF] Output will be stored in directory: $output_dir\n"
    fi

    # Defines the tool_out variable that will be used for each tool
    for tool in "${pd_tools[@]}"; do
        declare -g "${tool}_out=${clean_name}/${tool}_${clean_name}.txt"
        declare -g "${tool}_out_json=${clean_name}/${tool}_${clean_name}.json"
        declare -g "${tool}_sorted=${clean_name}/sorted_${tool}_${clean_name}.txt"
        declare -g "${tool}_sorted_json=${clean_name}/sorted_${tool}_${clean_name}.json"
    done
}

check_before_run() {
    local tool_name="$1"
    local tool_out="$2" 

    if [[ -f "$tool_out" && -s "$tool_out" ]]; then
        echo -e "\n[WRN] $tool_name output already exists. File: $tool_out"
        read -e -r -p "[OPT] Skip $tool_name (s), Overwrite File (o), or Backup File (b)? [S/o/b]: " choise
        
        case "$choise" in
            [sS]*)
                printf "[INF] Skipping $tool_name step.\n"
                return 1
                ;;
            [oO]*)
                printf "[INF] Overwriting existing file...\n"
                return 0
                ;;
            [bB]*)
                local timestamp=$(date +"%Y%m%d_%H%M")
                local backup_file="${tool_out}_${timestamp}.bak"
                mv "$tool_out" "$backup_file"
                printf "[INF] Moved existing results to: %s\n" "$backup_file"
                return 0
                ;;
            *) 
                printf "[ERR] Invalid option. Skipping Subfinder step.\n"
                return 0 
                ;;
        esac
    fi
    return 0
}

run_subfinder() {
    local subfinder_flags=(-d "$domain" -all -o "$subfinder_out" -silent)
  
    printf "\n[INF] Setting up Subfinder.\n"
    printf "[INF] This tool will run a passive scan.\n"
    printf "[INF] It is highly recommended to populate Subfinder's config file with API keys to enhance subdomain discovery.\n"
    printf "[INF] File: (~/.config/subfinder/provider-config.yaml)\n"

    while true; do
        printf "\n[!] Do you wish to configure it before running?\n"
        read -e -r -p "[OPT] Confirm (c) Skip step (s): " choice
        
        if [[ "$choice" =~ ^[cC]$ ]]; then
            printf "[!] Populate it now and select continue when done.\n"
            read -e -r -p "[OPT] Continue (c) Skip step (s): " add_choice
            
            if [[ "$add_choice" =~ ^[cC]$ ]]; then
                break
            else
                break
            fi
        else
            printf "[INF] Skipping step.\n"
            break
        fi
    done

    printf "\n####################################################################\n"
    printf "##################### Starting Subfinder ###########################\n"
    printf "####################################################################\n"

    subfinder "${subfinder_flags[@]}" &>/dev/null
    
    if [[ $? -eq 0 ]]; then
        local findings=$(wc -l <"$subfinder_out")
        printf "[INF] Subfinder done - $findings subdomains saved.\n"
    else
        printf "[ERR] Subfinder failed."
        return 1
    fi
}

run_shuffledns() {
    local wordlist="${PWD}/wordlist.txt"
    local resolvers="${PWD}/resolvers.txt"
    local shuffledns_flags=(-d "$domain" -w "$wordlist" -r "$resolvers" -mode bruteforce -o "$shuffledns_out" -silent)

    printf "\n[INF] Setting up ShuffleDNS\n"
    printf "[WRN] This tool runs a ACTIVE and NOISY scan.\n"
    printf "[!] Please select Confirm to continue\n"
    read -e -r -p "[OPT] Confirm (c) Skip step (s): " choice

    if [[ "$choice" =~ ^[cC]$ ]]; then
        true
    else
        printf "[INF] Skipping ShuffleDNS.\n\n"
        return 0
    fi


    printf "[INF] Shuffledns requires a list with public DNS resolvers and a bruteforcing wordlists for best results.\n"
    printf "      \n%s\n" "Recommended sources:"
    printf "   %s\n" "- Trickest  (Resolvers):  https://github.com/trickest/resolvers/blob/main/resolvers.txt"
    printf "   %s\n" "- SecLists  (Wordlists):  https://github.com/danielmiessler/SecLists"
    printf "   %s\n" "- AssetNote (Wordlists):  https://wordlists.assetnote.io"
    printf "\n[!] Download one and save it as resolvers.txt in your working directory.\n"
    printf "[!] Download one and save it as wordlist.txt in your working directory.\n\n"
    printf "[!] Please select Confirm to continue\n"
    
    while true; do
        read -e -r -p "[OPT] Confirm (c) Skip step (s): " add_choice
            if [[ "$add_choice" =~ ^[cC]$ ]]; then
                if [[ ! -f "$wordlist" || ! -f "$resolvers" ]]; then
                    printf "[ERR] Missing files! Ensure both wordlist.txt and resolvers.txt exist.\n"
                    continue
                else
                    break
                fi
            elif [[ "$add_choice" =~ ^[sS]$ ]]; then
                printf "[INF] Skipping step.\n"
                break
            else
                printf "[ERR] Wrong option.\n"
                continue
            fi
    done

    printf "\n###############################################################\n"
    printf "##################### Starting ShuffleDNS #####################\n"
    printf "###############################################################\n"

    shuffledns "${shuffledns_flags[@]}" &>/dev/null

    if [[ $? -eq 0 ]]; then
        local findings=$(wc -l < "$shuffledns_out")
        printf "\n[INF] ShuffleDNS done - $findings subdomains saved.\n"
    else
        printf "[ERR] ShuffleDNS failed."
        return 1
    fi
}

run_alterx() {
    local keywords_file="${PWD}/target-keywords.txt"
    local alterx_flags=("-silent" "-enrich" "-o" "$alterx_out")
    local file_input=""

    printf "\n[INF] Setting up AlterX\n"

    # Sort by uniqueness into a single file
    if [[ -s "$subfinder_out" && -s "$shuffledns_out" ]]; then
        sort -u "$subfinder_out" "$shuffledns_out" > "${domain}/sorted_subfinder_shuffledns.txt"
        file_input="${domain}/sorted_subfinder_shuffledns.txt"
    elif [[ -s "$subfinder_out" ]]; then
        printf "[WRN] ShuffleDNS results missing. Using Subfinder output only.\n"
        file_input="$subfinder_out"
    elif [[ -s "$shuffledns_out" ]]; then
        printf "[WRN] Subfinder results missing. Using ShuffleDNS output only.\n"
        file_input="$shuffledns_out"
    else
        printf "[ERR] No input files found for AlterX! Skipping.\n"
        return 1
    fi

    # Add target keywords
    printf "[INF] It is recommended to add target specific keywords to enhance results.\n"
    printf "[INF] : company products, acronyms, brands, language specific terms\n"
    printf "[!] Do you wish to add any?\n"
    read -e -r -p "[OPT] Add now (a) Skip action (s): " add_choice

    if [[ "$add_choice" =~ ^[aA]$ ]]; then
        while true; do
            printf "[!] create a file named target-keywords.txt containing a keyword per line.\n"
            read -e -r -p "[OPT] Continue (c) or Skip action (s): " loop_choice
            if [[ "$loop_choice" =~ ^[cC]$ ]]; then
                if [[ -s "$keywords_file" ]]; then
                    alterx_flags+=("-pp" "word=$keywords_file")
                    break
                else
                    printf "[ERR] File target-keywords.txt not found or empty.\n"
                fi
            elif [[ "$loop_choice" =~ ^[sS]$ ]]; then
                printf "[INF] Skipping action.\n"
                break
            fi
        done
    fi

    # Run AlterX
    printf "\n###############################################################\n"
    printf "#####################   Starting Alterx   #####################\n"
    printf "###############################################################\n"

    cat "$file_input" | alterx "${alterx_flags[@]}" &> /dev/null
    
    if [[ $? -eq 0 ]]; then
        local findings=$(wc -l < "$alterx_out")
        printf "\n[INF] AlterX done - $findings permutations saved.\n"
    else
        printf "[ERR] AlterX failed."
        return 1
    fi

    # Final sort to prevent duplications in big scopes
    sort -u "$alterx_out" > "$alterx_sorted" 
  }

run_dnsx() {
    local dnsx_flags=(-l "$alterx_sorted" -silent -a -aaaa -cname -resp-only -json -r resolvers.txt)
    local dnsx_flags+=( -t 150 -retry 3 -o "$dnsx_out_json")
    
    printf "\n###############################################################\n"
    printf "#####################    Starting dnsx    #####################\n"
    printf "###############################################################\n"

    printf "\n[INF] This an ACTIVE and NOISY step.\n"
    printf "[!] Select Confirm to start.\n"
    read -e -r -p "[OPT] Confirm (c) Skip step (s): " choice
    
    if [[ "$choice" =~ ^[cC]$ ]]; then
        printf "\n[INF] Starting dnsx. This will take a while.\n"
    else
        printf "[INF] Canceling action.\n"
        return 1
    fi

########################## OUTPUT #########################
#[INF] dnsx complete — 1247 resolved hosts
#[+] 1120 with A/AAAA records
#[+] 89 with CNAME (potential takeovers?)
#Sample:
#       api.domain.com → 192.0.2.1 | alias.domain.com
###########################################################

    dnsx "${dnsx_flags[@]}" &> /dev/null

    if [[ $? -eq 0 && -s "$dnsx_out_json" ]]; then
        local resolved_hosts=$(jq -c 'select(.host != null and (.a + .aaaa + .cname | length > 0))' "$dnsx_out_json" | wc -l)
        local resolved_a_aaaa=$(jq -c 'select((.a | length > 0) or (.aaaa | length > 0))' "$dnsx_out_json" | wc -l)
        local resolved_cname=$(jq -c 'select(.cname | length > 0)' "$dnsx_out_json" | wc -l)
        local resolved_sample=$(head -n 200 "$dnsx_out_json" | jq -r '
        select(.host != null and (.a[0] != null or .aaaa[0] != null) and .cname[0] != null) | "\(.host)\t->\t\((.a[0] // .aaaa[0]))\t|\t\(.cname[0])"
        ' | head -n 5 | column -t -s $'\t' | sed 's/^/       /')

        printf "[INF] dnsx done - %s resolved hosts.\n" "$resolved_hosts"
        printf " [+] %s with A/AAAA records.\n" "$resolved_a_aaaa"
        printf " [+] %s with CNAME (potential takeovers?)\n" "$resolved_cname"
        printf "Sample: \n%s\n" "$resolved_sample"
    else
        printf "\n[INF] No resolved hosts found.\n"
        printf "[ERR] dnsx failed.\n"
        return 1
    fi
}

# Run Naabu
#run_naabu() {printf "\n[WRN] This tool runs a ACTIVE and NOISY scan.\n"}
# User JSON output


# Run HTTPX
#run_httpx() {}
# Use JSON output.

# Run Katana
#run_katana() {printf "\n[WRN] This tool runs a ACTIVE and NOISY scan.\n"}
# Use JSON output.

# Run URLFinder
# Use JSON output

# Generate report
#generate_report() {}

##################
### Main Logic ###
##################

# Flags options
install_tools=()
verbose=false

while getopts ":i:vh" opt; do
    case $opt in
        i)
            if [[ "$OPTARG" == "tools" ]]; then
                install_tools+=("$OPTARG")
            else
                echo "[!] Invalid argument. Use [-i tools]" >&2
                exit 1
            fi
            ;;
        v) verbose=true ;;
        h)
            echo "[!] Usage: $0 [-i tools] [-v verbose] [-h help]"
            exit 0
            ;;
        *) 
            echo "[!] Usage: $0 [-i tools] [-v verbose] [-h help]"
            exit 0
            ;;
    esac
done

shift $((OPTIND-1))

for task in "${install_tools[@]}"; do
    case "$task" in
        "tools")
            install_script_tools
            ;;

    esac
done

[[ $verbose == true ]] && set -x

#### ------ Phase 1: Asset Discovery ------ ####

## Logo here
## Legal disclaimer here
## Initial instructions here

# Define domain and output directory
define_variables || { echo "[DBG] define_variables failed."; exit 1; }

printf "\n####################################################################\n"
printf "##################### Phase 1: Asset Discovery #####################\n"
printf "####################################################################\n"

# Perform a check before running Subfinder and continue, otherwise skip it.
if check_before_run subfinder "$subfinder_out"; then
    run_subfinder "$domain" "$output_dir" 
fi

# Perform a check before running ShuffleDNS and continue, otherwise skip it.
if check_before_run shuffledns "$shuffledns_out"; then
    run_shuffledns
fi

# Configure and run AlterX
if check_before_run alterx "$alterx_out"; then
    run_alterx
fi

# Configure and run DNSX
if check_before_run dnsx "$dnsx_out_json"; then
    run_dnsx
fi

# Configure and run ShuffleDNS

# Configure and run Naabu

#### ------ Phase 2: Content Discovery ---- ####

# Configure and run HTTPX

# Configure and run Katana

# Consider run URLFinder with Katana to gather URLs from external sources

#### ------ Phase 3: Report Generation ------ ####

# Generate report

